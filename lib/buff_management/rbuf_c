#ifndef BUFF_H
#define BUFF_H

#include "rbuf.h"

extern pthread_mutex_t list_lock;
extern pthread_cond_t readable;
extern int listready;
extern struct data_entry *data_entry_head;
extern struct rbuf_entry *rbuf_entry_head;

struct rbuf_entry *new_rbuf()
{
	int i;
	struct rbuf_entry *e, *prev_ptr, *head;

	prev_ptr = NULL;

	pthread_mutex_t list_lock;
	pthread_mutexattr_t attrs;

        list_lock = PTHREAD_MUTEX_INITIALIZER;

        pthread_mutexattr_init(&attrs);

	/* INITIALIZE LIST OF BUFFERS */
	for (i = 64; i >= 1; i--) {
	    e = malloc(sizeof(struct rbuf_entry));

	    e->id = i;
	    e->iov[0].iov_len = BUFF_SIZE;
	    e->iov[0].iov_base = e->line;
 	    pthread_mutex_init(&e->lock, &attrs);

	    if ( prev_ptr != NULL ) {
		prev_ptr->next = e;
	    } else {
		head = e;
	    }
	    prev_ptr = e;
/*	    e = e->next; */
	}

	return head;
}


void rbuf_write(void *fd)
{

	struct rbuf_entry *w_ptr;

	w_ptr = rbuf_entry_head;
	
	int r;

	pthread_mutex_lock(&list_lock);

	while (listready == 0)
		pthread_cond_wait(&readable, &list_lock);

	pthread_mutex_unlock(&list_lock);

	if (pthread_mutex_lock(&w_ptr->lock) != 0 )
		printf("W.1.1: Failed to get lock for %d\n", w_ptr->id);

	for (; ;) {
		if ( (r = writev(*(int *)fd, w_ptr->iov, 1)) <= 0) {
			printf("Error ######### %d %s\n", errno, strerror(errno));
			pthread_mutex_unlock(&w_ptr->lock);
			pthread_exit(NULL);
		} else {
			printf("\nW: WROTE %d bytes from %d\n", r, w_ptr->id);
		}

		w_ptr->iov[0].iov_len = BUFF_SIZE;

		if (pthread_mutex_lock(&w_ptr->next->lock) != 0 ) {
			printf("W: failed to get lock %d %s\n", errno, strerror(errno));
			exit(-1);
		}
		if (pthread_mutex_unlock(&w_ptr->lock) < 0)
			printf("W.3.1: failed to unlock %d %s\n",  w_ptr->id);
		w_ptr = w_ptr->next;
/* 		sleep(1); */
	}	
}

void rbuf_read(void *fd)
{
	struct data_entry *r_ptr;
	int i, r;

	r_ptr = data_entry_head;

	printf("In READ call\n");

	pthread_cleanup_push(read_cleanup, NULL);

	printf("R.1: Grabbing lock for %d\n", r_ptr->id);

	/* CALL pthread_conf_signal() TO SYNCHRONIZE 
	* LOCKING OF FIRST ENTRY IN LIST.  THIS THREAD 
	* MUST GET THE LOCK FIRST.
	*/

	/* GRAB LOCK */
	if (pthread_mutex_lock(&r_ptr->lock) != 0)
		printf("R: error locking %d\n", r_ptr->id);

	pthread_mutex_lock(&list_lock);
	listready = 1;
	pthread_mutex_unlock(&list_lock);

	/* SIGNAL WRITE THREAD */
	pthread_cond_signal(&readable);

	for ( ; ; ) {

		printf("Calling readv\n");

		while ((i = readv(*(int *)fd, r_ptr->iov, 1)) > 0 ) {
			printf("R: read %d bytes to %d\n", i, r_ptr->id);
			r_ptr->iov[0].iov_len = i;
	
			printf("R.2: Grabbing lock for %d\n", r_ptr->next->id);
			if (pthread_mutex_lock(&r_ptr->next->lock) < 0) {
				printf("R: error locking %d\n", r_ptr->next->id);
				exit(-1);
			}
 
			printf("R.3: unlocking %d\n", r_ptr->id);
			if (pthread_mutex_unlock(&r_ptr->lock) < 0) {
                                printf("R: error unlocking %d\n", r_ptr->id);
                                exit(-1);
                        }

			printf("R.4: unlocked %d\n", r_ptr->id);
			r_ptr = r_ptr->next;
		}
	}

	pthread_cleanup_pop(0);
}

void read_cleanup(void *a)
{

	if (pthread_mutex_unlock(&r_ptr->lock) == 0) {
		printf("R.C.1 cleaned up lock for %d\n", r_ptr->id);
	} else {
		printf("R.C.1 failed cleanup of lock for %d: %d %s\n", r_ptr->id, errno, strerror(errno));
	}

	if (pthread_mutex_unlock(&r_ptr->next->lock) == 0) {
		printf("R.C.2: unlocedk for %d\n", r_ptr->next->id);
	} else {
                printf("R.C.2: failed cleanup of lock for %d: %d %s\n", r_ptr->next->id, errno, strerror(errno));
	}
}


#endif
